Chap3 Machine-Level Representation of Programs

  - Computers execute machine code, sequences of bytes encoding the low-level operations that manipulate data, manage memory, read and write data on storage devices, and communicate over networks.
  - A compiler generates machine code through a series of stages, based on: the rules of the programming language / the instruction set of the target machine / the conventions followed by the operating system.
  - The GCC C compiler generates its output in the form of assembly code, then invokes both an assembler and a linker to generate the executable machine code from the assembly code.
  - A high-level language hides information about the run-time behavior of a program that we need to understand:
    - For example, understand how program data are shared or kept private by the different threads and precisely how and where shared data are accessed.
    - Understanding how vulnerabilities arise and how to guard against them requires a knowledge of the machine-level representation of programs.
  - What is x86-64?  
    - Instruction set architecture(ISA), sometimes also called computer architecture(not the micro processor physical architecture ), defines the supported instructions, data types, registers, the hardware support for managing main memory etc.
    - A device that executes instructions described by that ISA, such as a central processing unit (CPU), is called an implementation of that ISA.
    - A x86-64 is a 64-bit version of the x86 instruction set, first released in 1999. 
    - x86 (also known as 80x86 or the 8086 family) is a family of complex instruction set computer (CISC) instruction set architectures initially developed by Intel based on the Intel 8086.
    - this book's presentation is based on x86-64, the machine language(not machine code) for most of the processors found in today's laptop and desktop machines, as well as those that power very large data centers and supercomputers.
    - IA32, the 32-bit predecessor to x86-64, was introduced by Intel in 198S. It served as the machine language of choice for several decades. Most x86 microprocess sold today and opereating system designed to run on x86-64, can also execute IA32 programs in a backward compatibility mode.
  - The evolutionary development of x86
    - It started with one of the first single-chip 16-bit microprocessors.
    - 8086: In 1987, One of the first single-chip, 16-bit microprocessors.
    - 8088: a variant of the 8086 with an 8-bit external bus, formed the heart of the original IBM personal computers.
    - 8087: In 1980, floating-point coprocessor, operate alongside an 8086 or 8088 processor, executing the floating-point instructions, established the floating-point model for the x86 line, often referred to as "x87."
    - 80286: In 1982, Added more (and now obsolete) addressing modes. Formed the basis of the IBM PC-AT personal computer, the original platform for MS Windows.
    - i386: In 1985, Expanded the architecture to 32 bits. Added the flat addressing model used by Linux and recent versions of the Windows operating system. This was the first machine in the series that could fully support a Unix operating system.
    - i486: In 1989, Improved performance and integrated the floating-point unit onto the processor chip but did not significantly change the instruction set.
    - Pentium: In 1993, Improved performance but only added minor extensions to the instruction set.
    - PentiumPro: In 1995, Introduced a radically new processor design, internally known as the P6 microarchitecture. Added a class of "conditional move" instructions to the instruction set.
    - Pentium/MMX: In 1997, Added new class of instructions to the Pentium processor for manipulating vectors of integers. Each datum can be 1, 2, or 4 bytes long. Each vector totals 64 bits.
    - PentiumII: In 1997, Continuation of the P6 microarchitecture
    - PentiumIII: In 1999, Introduced SSE, a class of instructions for manipulating vectors of integer or floating-point data. Each datum can be 1, 2, or 4 bytes, packed into vectors of 128 bits.
    - Pentium 4: In 2000, Extended SSE to SSE2, adding new data types (including double-precision floating point), along with 144 new instructions for these formats. With these extensions, compilers can use SSE instructions, rather than x87 instructions, to compile floating-point code.
    - Pentium4E: In 2004, Added hyperthreading, a method to run two programs simultaneously on a single processor, as well as EM64T, Intel's implementation of a 64-bit extension to IA32 developed by AMD ,which we refer to as x86-64.
    - Core 2: In 2006, Returned to a microarchitecture similar to P6. First multi-core Intel microprocessor, where multiple processors are implemented on a single chip. Did not support hyperthreading.
    - Corei7-Nehalem: In 2008, Incorporated both hyperthreading and multi-core, with the initial version supporting two executing programs on each core and up to four cores on each chip.
    - Core i7-Sandy Bridge: In 2011, Introduced AVX, an extension of the SSE to support data packed into 256-bit vectors.
    - Core i7, Haswell: In 2013, Extended AVX to AVX2, adding more instructions and instruction formats.
    - Each successive processor has been designed to be backward compatible, able to run code compiled for any earlier version.( there are many strange artifacts in the instruction set due to this evolutionary heritage).
    - Intel has had several names for their processor line, including "IA32"(for "Intel Architecture 32-bit" ) and most recently "Intel64"(the 64-bit extension to IA32) , which we will refer to as x86-64. 
    - We will refer to the overall line by the commonly used colloquial name "x86," reflecting the processor naming conventions up through the i486.

